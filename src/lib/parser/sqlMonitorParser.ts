import type { PlanNode, ParsedPlan } from '../types';
import type { PlanParser } from './types';

/**
 * Parser for Oracle SQL Monitor text report output.
 * Generated by DBMS_SQLTUNE.REPORT_SQL_MONITOR with TYPE='TEXT'.
 */
export const sqlMonitorTextParser: PlanParser = {
  canParse(input: string): boolean {
    // SQL Monitor text reports typically contain these markers
    return (
      /SQL Monitoring Report/i.test(input) ||
      /SQL Plan Monitoring Details/i.test(input) ||
      /Global Stats/i.test(input) ||
      (/\|\s*Id\s*\|.*A-Rows/i.test(input)) // Has actual rows column
    );
  },

  parse(input: string): ParsedPlan {
    const lines = input.split('\n');

    // Extract SQL ID if present
    const sqlId = extractSqlId(lines);
    const planHashValue = extractPlanHashValue(lines);

    // Parse the plan table with actual statistics
    const tableData = parseSqlMonitorTable(lines);

    if (tableData.length === 0) {
      return {
        planHashValue,
        sqlId,
        rootNode: null,
        allNodes: [],
        totalCost: 0,
        maxRows: 0,
        source: 'sql_monitor_text',
        hasActualStats: false,
      };
    }

    // Parse predicate information (same format as DBMS_XPLAN)
    const predicates = parsePredicates(lines);

    // Build tree structure
    const { rootNode, allNodes } = buildTree(tableData, predicates);

    // Calculate totals
    const totalCost = allNodes.reduce((sum, node) => sum + (node.cost || 0), 0);
    const maxRows = Math.max(...allNodes.map(node => node.rows || 0));
    const maxActualRows = Math.max(...allNodes.map(node => node.actualRows || 0), 0);
    const maxStarts = Math.max(...allNodes.map(node => node.starts || 0), 0);
    const hasActualStats = allNodes.some(node => node.actualRows !== undefined);

    // A-Time is cumulative: root node's actualTime is the total elapsed time
    const totalElapsedTime = rootNode?.actualTime || 0;

    return {
      planHashValue,
      sqlId,
      rootNode,
      allNodes,
      totalCost,
      maxRows: hasActualStats ? maxActualRows : maxRows,
      maxActualRows: hasActualStats ? maxActualRows : undefined,
      maxStarts: hasActualStats ? maxStarts : undefined,
      source: 'sql_monitor_text',
      hasActualStats,
      totalElapsedTime,
    };
  },
};

/**
 * Parser for Oracle SQL Monitor XML report output.
 * Generated by DBMS_SQLTUNE.REPORT_SQL_MONITOR with TYPE='XML'.
 */
export const sqlMonitorXmlParser: PlanParser = {
  canParse(input: string): boolean {
    // XML reports start with XML declaration or contain sql_monitor tags
    return (
      /^\s*<\?xml/i.test(input) ||
      /<sql_monitor/i.test(input) ||
      /<report/i.test(input)
    );
  },

  parse(input: string): ParsedPlan {
    // Parse the XML document
    const parser = new DOMParser();
    const doc = parser.parseFromString(input, 'text/xml');

    // Check for parse errors
    const parseError = doc.querySelector('parsererror');
    if (parseError) {
      return {
        rootNode: null,
        allNodes: [],
        totalCost: 0,
        maxRows: 0,
        source: 'sql_monitor_xml',
        hasActualStats: false,
      };
    }

    // Extract metadata
    const sqlId = getXmlText(doc, 'sql_id');
    const planHashValue = getXmlText(doc, 'plan_hash');
    const sqlText = getXmlText(doc, 'sql_text');

    // Parse plan operations
    const operations = doc.querySelectorAll('operation');
    const allNodes: PlanNode[] = [];
    const nodeMap = new Map<number, PlanNode>();

    operations.forEach((op) => {
      const node = parseXmlOperation(op);
      if (node) {
        nodeMap.set(node.id, node);
        allNodes.push(node);
      }
    });

    // Build parent-child relationships
    allNodes.forEach((node) => {
      if (node.parentId !== undefined) {
        const parent = nodeMap.get(node.parentId);
        if (parent) {
          parent.children.push(node);
        }
      }
    });

    // Find root node (usually id 0 or the one without a parent)
    const rootNode = nodeMap.get(0) || allNodes.find(n => n.parentId === undefined) || null;

    // Calculate totals
    const totalCost = allNodes.reduce((sum, node) => sum + (node.cost || 0), 0);
    const maxRows = Math.max(...allNodes.map(node => node.actualRows || node.rows || 0), 0);
    const maxActualRows = Math.max(...allNodes.map(node => node.actualRows || 0), 0);
    const maxStarts = Math.max(...allNodes.map(node => node.starts || 0), 0);
    const hasActualStats = allNodes.some(node => node.actualRows !== undefined);
    // A-Time is cumulative: root node's actualTime is the total elapsed time
    const totalElapsedTime = rootNode?.actualTime || 0;

    return {
      planHashValue,
      sqlId,
      sqlText,
      rootNode,
      allNodes,
      totalCost,
      maxRows,
      maxActualRows: hasActualStats ? maxActualRows : undefined,
      maxStarts: hasActualStats ? maxStarts : undefined,
      source: 'sql_monitor_xml',
      hasActualStats,
      totalElapsedTime,
    };
  },
};

// Helper functions for text parser

interface RawSqlMonitorRow {
  id: number;
  operation: string;
  objectName?: string;
  rows?: number;
  cost?: number;
  actualRows?: number;
  actualTime?: number;
  starts?: number;
  memoryUsed?: number;
  tempUsed?: number;
  physicalReads?: number;
  logicalReads?: number;
  activityPercent?: number;
  depth: number;
}

function extractSqlId(lines: string[]): string | undefined {
  for (const line of lines) {
    const match = line.match(/SQL\s*ID[:\s]+(\w+)/i);
    if (match) {
      return match[1];
    }
  }
  return undefined;
}

function extractPlanHashValue(lines: string[]): string | undefined {
  for (const line of lines) {
    const match = line.match(/Plan Hash[^=\d]*[=:\s]+(\d+)/i);
    if (match) {
      return match[1];
    }
  }
  return undefined;
}

interface SqlMonitorColumnPositions {
  id: { start: number; end: number };
  operation: { start: number; end: number };
  name: { start: number; end: number };
  rows?: { start: number; end: number };
  cost?: { start: number; end: number };
  aRows?: { start: number; end: number };
  aTime?: { start: number; end: number };
  starts?: { start: number; end: number };
  memory?: { start: number; end: number };
  temp?: { start: number; end: number };
  reads?: { start: number; end: number };
  activity?: { start: number; end: number };
}

function parseSqlMonitorTable(lines: string[]): RawSqlMonitorRow[] {
  const rows: RawSqlMonitorRow[] = [];

  // Find the header line
  let headerLineIndex = -1;
  let headerLine = '';

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (/\|\s*Id\s*\|.*Operation/i.test(line)) {
      headerLineIndex = i;
      headerLine = line;
      break;
    }
  }

  if (headerLineIndex === -1) {
    return rows;
  }

  // Parse column positions
  const columns = parseSqlMonitorColumnPositions(headerLine);

  // Parse data rows
  for (let i = headerLineIndex + 1; i < lines.length; i++) {
    const line = lines[i];

    if (/^[-|=]+$/.test(line.trim()) || line.trim() === '') {
      if (/^[-|=]+$/.test(line.trim())) {
        let foundMoreData = false;
        for (let j = i + 1; j < lines.length; j++) {
          if (/^\|.*\d+.*\|/.test(lines[j])) {
            foundMoreData = true;
            break;
          }
          if (/^[-|=]+$/.test(lines[j].trim())) {
            break;
          }
        }
        if (!foundMoreData) {
          break;
        }
      }
      continue;
    }

    if (/^\|/.test(line)) {
      const row = parseSqlMonitorDataRow(line, columns);
      if (row) {
        rows.push(row);
      }
    }
  }

  return rows;
}

function parseSqlMonitorColumnPositions(headerLine: string): SqlMonitorColumnPositions {
  const cols: SqlMonitorColumnPositions = {
    id: { start: 0, end: 0 },
    operation: { start: 0, end: 0 },
    name: { start: 0, end: 0 },
  };

  const pipePositions: number[] = [];
  for (let i = 0; i < headerLine.length; i++) {
    if (headerLine[i] === '|') {
      pipePositions.push(i);
    }
  }

  const headerLower = headerLine.toLowerCase();
  let rowsSeen = false;

  for (let i = 0; i < pipePositions.length - 1; i++) {
    const start = pipePositions[i] + 1;
    const end = pipePositions[i + 1];
    const segment = headerLower.substring(start, end).trim();

    if (segment === 'id') {
      cols.id = { start, end };
    } else if (segment === 'operation') {
      cols.operation = { start, end };
    } else if (segment === 'name' || segment === 'object name') {
      cols.name = { start, end };
    } else if (segment === 'e-rows' || segment === 'rows' || segment === 'rows (estim)') {
      // Real SQL Monitor reports have two 'Rows' columns: first = estimated, second = actual
      if (segment === 'e-rows' || !rowsSeen) {
        cols.rows = { start, end };
        if (segment === 'rows') rowsSeen = true;
      } else {
        cols.aRows = { start, end };
      }
    } else if (segment.includes('cost')) {
      cols.cost = { start, end };
    } else if (segment === 'a-rows' || segment === 'actual rows' || segment === 'rows (actual)') {
      cols.aRows = { start, end };
    } else if (segment === 'a-time' || segment === 'actual time' || segment === 'time' || segment === 'time active(s)' || segment === 'time active (s)') {
      cols.aTime = { start, end };
    } else if (segment === 'starts' || segment === 'execs') {
      cols.starts = { start, end };
    } else if (segment.includes('mem') || segment === 'omem' || segment === 'used-mem') {
      cols.memory = { start, end };
    } else if (segment.includes('temp') || segment === 'used-tmp') {
      cols.temp = { start, end };
    } else if (segment === 'reads' || segment === 'physical reads') {
      cols.reads = { start, end };
    } else if (segment === 'activity' || segment === 'activity %') {
      cols.activity = { start, end };
    }
  }

  return cols;
}

function parseSqlMonitorDataRow(line: string, columns: SqlMonitorColumnPositions): RawSqlMonitorRow | null {
  const idStr = line.substring(columns.id.start, columns.id.end).trim();
  const idMatch = idStr.match(/\*?\s*(\d+)/);
  if (!idMatch) {
    return null;
  }

  const id = parseInt(idMatch[1], 10);

  const operationRaw = line.substring(columns.operation.start, columns.operation.end);
  const depth = calculateDepth(operationRaw);
  const operation = operationRaw.trim();

  if (!operation) {
    return null;
  }

  const objectName = line.substring(columns.name.start, columns.name.end).trim() || undefined;

  const row: RawSqlMonitorRow = {
    id,
    operation,
    objectName,
    depth,
  };

  if (columns.rows) {
    const val = parseNumericValue(line.substring(columns.rows.start, columns.rows.end).trim());
    if (val !== null) row.rows = val;
  }

  if (columns.cost) {
    const val = parseNumericValue(line.substring(columns.cost.start, columns.cost.end).trim());
    if (val !== null) row.cost = val;
  }

  if (columns.aRows) {
    const val = parseNumericValue(line.substring(columns.aRows.start, columns.aRows.end).trim());
    if (val !== null) row.actualRows = val;
  }

  if (columns.aTime) {
    const timeStr = line.substring(columns.aTime.start, columns.aTime.end).trim();
    const timeMs = parseTimeToMs(timeStr);
    if (timeMs !== null) row.actualTime = timeMs;
  }

  if (columns.starts) {
    const val = parseNumericValue(line.substring(columns.starts.start, columns.starts.end).trim());
    if (val !== null) row.starts = val;
  }

  if (columns.memory) {
    const val = parseMemoryValue(line.substring(columns.memory.start, columns.memory.end).trim());
    if (val !== null) row.memoryUsed = val;
  }

  if (columns.temp) {
    const val = parseMemoryValue(line.substring(columns.temp.start, columns.temp.end).trim());
    if (val !== null) row.tempUsed = val;
  }

  if (columns.reads) {
    const val = parseNumericValue(line.substring(columns.reads.start, columns.reads.end).trim());
    if (val !== null) row.physicalReads = val;
  }

  if (columns.activity) {
    const actStr = line.substring(columns.activity.start, columns.activity.end).trim();
    const actMatch = actStr.match(/([\d.]+)/);
    if (actMatch) row.activityPercent = parseFloat(actMatch[1]);
  }

  return row;
}

function calculateDepth(operationStr: string): number {
  let spaces = 0;
  for (const char of operationStr) {
    if (char === ' ') {
      spaces++;
    } else {
      break;
    }
  }
  return Math.floor(spaces / 1);
}

function parseNumericValue(str: string): number | null {
  const cleaned = str.replace(/,/g, '').trim();
  if (!cleaned || cleaned === '') return null;

  const suffixMatch = cleaned.match(/^([\d.]+)\s*([KMG])?$/i);
  if (suffixMatch) {
    let value = parseFloat(suffixMatch[1]);
    const suffix = (suffixMatch[2] || '').toUpperCase();
    if (suffix === 'K') value *= 1000;
    else if (suffix === 'M') value *= 1000000;
    else if (suffix === 'G') value *= 1000000000;
    return Math.round(value);
  }

  const num = parseInt(cleaned, 10);
  return isNaN(num) ? null : num;
}

function parseTimeToMs(timeStr: string): number | null {
  if (!timeStr) return null;

  // Format: HH:MM:SS.ss or SS.ss or similar
  const hhmmssMatch = timeStr.match(/(\d+):(\d+):(\d+)(?:\.(\d+))?/);
  if (hhmmssMatch) {
    const hours = parseInt(hhmmssMatch[1], 10);
    const minutes = parseInt(hhmmssMatch[2], 10);
    const seconds = parseInt(hhmmssMatch[3], 10);
    const fraction = hhmmssMatch[4] ? parseInt(hhmmssMatch[4], 10) / Math.pow(10, hhmmssMatch[4].length) : 0;
    return (hours * 3600 + minutes * 60 + seconds + fraction) * 1000;
  }

  // Just seconds
  const secMatch = timeStr.match(/([\d.]+)\s*(?:s|sec)?/i);
  if (secMatch) {
    return parseFloat(secMatch[1]) * 1000;
  }

  return null;
}

function parseMemoryValue(str: string): number | null {
  const cleaned = str.replace(/,/g, '').trim();
  if (!cleaned) return null;

  const match = cleaned.match(/^([\d.]+)\s*([KMGT])?B?$/i);
  if (match) {
    let value = parseFloat(match[1]);
    const suffix = (match[2] || '').toUpperCase();
    if (suffix === 'K') value *= 1024;
    else if (suffix === 'M') value *= 1024 * 1024;
    else if (suffix === 'G') value *= 1024 * 1024 * 1024;
    else if (suffix === 'T') value *= 1024 * 1024 * 1024 * 1024;
    return Math.round(value);
  }

  return parseNumericValue(str);
}

function parsePredicates(lines: string[]): Map<number, { access?: string; filter?: string }> {
  const predicates = new Map<number, { access?: string; filter?: string }>();

  // Find predicate section
  let inPredicateSection = false;
  let currentId: number | null = null;
  let currentType: 'access' | 'filter' | null = null;
  let currentText = '';

  for (const line of lines) {
    if (/Predicate Information/i.test(line)) {
      inPredicateSection = true;
      continue;
    }

    if (!inPredicateSection) {
      continue;
    }

    // Stop at next section or empty lines after predicates
    if (/^[A-Z].*:$/i.test(line.trim()) && !/^\s*\d+\s*-/.test(line)) {
      break;
    }

    // Parse predicate lines like "3 - access(...)" or "3 - filter(...)"
    const predicateMatch = line.match(/^\s*(\d+)\s*-\s*(access|filter)\s*\((.+)\)?\s*$/i);
    if (predicateMatch) {
      // Save previous predicate if any
      if (currentId !== null && currentType && currentText) {
        const existing = predicates.get(currentId) || {};
        existing[currentType] = currentText;
        predicates.set(currentId, existing);
      }

      currentId = parseInt(predicateMatch[1], 10);
      currentType = predicateMatch[2].toLowerCase() as 'access' | 'filter';
      currentText = predicateMatch[3] || '';

      // Handle case where predicate text is complete on this line
      if (currentText.endsWith(')') || !line.includes('(')) {
        const existing = predicates.get(currentId) || {};
        existing[currentType] = currentText.replace(/\)$/, '');
        predicates.set(currentId, existing);
        currentId = null;
        currentType = null;
        currentText = '';
      }
    } else if (currentId !== null && currentType && line.trim()) {
      // Continuation of multi-line predicate
      currentText += ' ' + line.trim();
      if (line.trim().endsWith(')')) {
        const existing = predicates.get(currentId) || {};
        existing[currentType] = currentText.replace(/\)$/, '');
        predicates.set(currentId, existing);
        currentId = null;
        currentType = null;
        currentText = '';
      }
    }
  }

  // Save any remaining predicate
  if (currentId !== null && currentType && currentText) {
    const existing = predicates.get(currentId) || {};
    existing[currentType] = currentText.replace(/\)$/, '');
    predicates.set(currentId, existing);
  }

  return predicates;
}

function buildTree(
  rows: RawSqlMonitorRow[],
  predicates: Map<number, { access?: string; filter?: string }>
): { rootNode: PlanNode | null; allNodes: PlanNode[] } {
  if (rows.length === 0) {
    return { rootNode: null, allNodes: [] };
  }

  const nodeMap = new Map<number, PlanNode>();
  const allNodes: PlanNode[] = [];

  for (const row of rows) {
    const preds = predicates.get(row.id);
    const node: PlanNode = {
      id: row.id,
      depth: row.depth,
      operation: row.operation,
      objectName: row.objectName,
      rows: row.rows,
      cost: row.cost,
      actualRows: row.actualRows,
      actualTime: row.actualTime,
      starts: row.starts,
      memoryUsed: row.memoryUsed,
      tempUsed: row.tempUsed,
      physicalReads: row.physicalReads,
      activityPercent: row.activityPercent,
      accessPredicates: preds?.access,
      filterPredicates: preds?.filter,
      children: [],
    };

    nodeMap.set(row.id, node);
    allNodes.push(node);
  }

  // Build parent-child relationships
  for (let i = 1; i < rows.length; i++) {
    const currentRow = rows[i];
    const currentNode = nodeMap.get(currentRow.id)!;

    for (let j = i - 1; j >= 0; j--) {
      const potentialParentRow = rows[j];
      if (potentialParentRow.depth < currentRow.depth) {
        const parentNode = nodeMap.get(potentialParentRow.id)!;
        parentNode.children.push(currentNode);
        currentNode.parentId = parentNode.id;
        break;
      }
    }
  }

  const rootNode = nodeMap.get(0) || allNodes[0] || null;
  return { rootNode, allNodes };
}

// Helper functions for XML parser

function getXmlText(doc: Document, tagName: string): string | undefined {
  const element = doc.querySelector(tagName);
  return element?.textContent?.trim() || undefined;
}

function parseXmlOperation(op: Element): PlanNode | null {
  const idAttr = op.getAttribute('id');
  if (!idAttr) return null;

  const id = parseInt(idAttr, 10);
  const operation = op.getAttribute('name') || op.querySelector('operation_name')?.textContent || '';
  const depth = parseInt(op.getAttribute('depth') || '0', 10);

  const node: PlanNode = {
    id,
    depth,
    operation,
    objectName: op.getAttribute('object_name') || op.querySelector('object_name')?.textContent || undefined,
    rows: parseXmlNumber(op, 'cardinality') || parseXmlNumber(op, 'e_rows'),
    bytes: parseXmlNumber(op, 'bytes'),
    cost: parseXmlNumber(op, 'cost'),
    actualRows: parseXmlNumber(op, 'output_rows') || parseXmlNumber(op, 'a_rows'),
    actualTime: parseXmlNumber(op, 'elapsed_time'),
    starts: parseXmlNumber(op, 'starts'),
    memoryUsed: parseXmlNumber(op, 'max_memory') || parseXmlNumber(op, 'used_mem'),
    tempUsed: parseXmlNumber(op, 'temp_space') || parseXmlNumber(op, 'used_tmp'),
    physicalReads: parseXmlNumber(op, 'physical_reads') || parseXmlNumber(op, 'cr_buffer_gets'),
    logicalReads: parseXmlNumber(op, 'logical_reads') || parseXmlNumber(op, 'buffer_gets'),
    activityPercent: parseXmlFloat(op, 'activity_percent') || parseXmlFloat(op, 'percent'),
    accessPredicates: op.querySelector('access_predicates')?.textContent?.trim(),
    filterPredicates: op.querySelector('filter_predicates')?.textContent?.trim(),
    children: [],
  };

  // Get parent ID if available
  const parentAttr = op.getAttribute('parent_id');
  if (parentAttr) {
    node.parentId = parseInt(parentAttr, 10);
  }

  return node;
}

function parseXmlNumber(element: Element, tagName: string): number | undefined {
  const value = element.getAttribute(tagName) || element.querySelector(tagName)?.textContent;
  if (!value) return undefined;
  const num = parseInt(value, 10);
  return isNaN(num) ? undefined : num;
}

function parseXmlFloat(element: Element, tagName: string): number | undefined {
  const value = element.getAttribute(tagName) || element.querySelector(tagName)?.textContent;
  if (!value) return undefined;
  const num = parseFloat(value);
  return isNaN(num) ? undefined : num;
}
