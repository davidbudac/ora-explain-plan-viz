import type { PlanNode, ParsedPlan } from '../types';
import type { PlanParser } from './types';

/**
 * Parser for Oracle SQL Monitor text report output.
 * Generated by DBMS_SQLTUNE.REPORT_SQL_MONITOR with TYPE='TEXT'.
 */
export const sqlMonitorTextParser: PlanParser = {
  canParse(input: string): boolean {
    // SQL Monitor text reports typically contain these markers
    return (
      /SQL Monitoring Report/i.test(input) ||
      /SQL Plan Monitoring Details/i.test(input) ||
      /Global Stats/i.test(input) ||
      (/\|\s*Id\s*\|.*A-Rows/i.test(input)) // Has actual rows column
    );
  },

  parse(input: string): ParsedPlan {
    const lines = input.split('\n');

    // Extract SQL ID if present
    const sqlId = extractSqlId(lines);
    const planHashValue = extractPlanHashValue(lines);

    // Parse the plan table with actual statistics
    const tableData = parseSqlMonitorTable(lines);

    if (tableData.length === 0) {
      return {
        planHashValue,
        sqlId,
        rootNode: null,
        allNodes: [],
        totalCost: 0,
        maxRows: 0,
        source: 'sql_monitor_text',
        hasActualStats: false,
      };
    }

    // Parse predicate information (same format as DBMS_XPLAN)
    const predicates = parsePredicates(lines);

    // Build tree structure
    const { rootNode, allNodes } = buildTree(tableData, predicates);

    // Calculate totals
    const totalCost = allNodes.reduce((sum, node) => sum + (node.cost || 0), 0);
    const maxRows = Math.max(...allNodes.map(node => node.rows || 0));
    const maxActualRows = Math.max(...allNodes.map(node => node.actualRows || 0), 0);
    const maxStarts = Math.max(...allNodes.map(node => node.starts || 0), 0);
    const hasActualStats = allNodes.some(node => node.actualRows !== undefined);

    // A-Time is cumulative: root node's actualTime is the total elapsed time
    const totalElapsedTime = rootNode?.actualTime || 0;

    return {
      planHashValue,
      sqlId,
      rootNode,
      allNodes,
      totalCost,
      maxRows: hasActualStats ? maxActualRows : maxRows,
      maxActualRows: hasActualStats ? maxActualRows : undefined,
      maxStarts: hasActualStats ? maxStarts : undefined,
      source: 'sql_monitor_text',
      hasActualStats,
      totalElapsedTime,
    };
  },
};

/**
 * Parser for Oracle SQL Monitor XML report output.
 * Handles the real Oracle format from DBMS_SQL_MONITOR.REPORT_SQL_MONITOR(type=>'XML')
 * which has separate <plan> (estimates) and <plan_monitor> (actuals) sections,
 * as well as a legacy simplified format.
 */
export const sqlMonitorXmlParser: PlanParser = {
  canParse(input: string): boolean {
    // XML reports start with XML declaration or contain sql_monitor/report tags
    return (
      /^\s*<\?xml/i.test(input) ||
      /<sql_monitor_report/i.test(input) ||
      /<sql_monitor/i.test(input) ||
      /<plan_monitor/i.test(input) ||
      (/<report[\s>]/i.test(input) && /<operation/i.test(input))
    );
  },

  parse(input: string): ParsedPlan {
    const domParser = new DOMParser();
    const doc = domParser.parseFromString(input, 'text/xml');

    // Check for parse errors
    const parseError = doc.querySelector('parsererror');
    if (parseError) {
      return {
        rootNode: null,
        allNodes: [],
        totalCost: 0,
        maxRows: 0,
        source: 'sql_monitor_xml',
        hasActualStats: false,
      };
    }

    // Detect format: real Oracle format has <plan_monitor> or <sql_monitor_report>
    const isRealOracleFormat = !!(
      doc.querySelector('plan_monitor') ||
      doc.querySelector('sql_monitor_report')
    );

    if (isRealOracleFormat) {
      return parseRealOracleXml(doc);
    } else {
      return parseLegacyXml(doc);
    }
  },
};

// Helper functions for text parser

interface RawSqlMonitorRow {
  id: number;
  operation: string;
  objectName?: string;
  rows?: number;
  cost?: number;
  actualRows?: number;
  actualTime?: number;
  starts?: number;
  memoryUsed?: number;
  tempUsed?: number;
  physicalReads?: number;
  logicalReads?: number;
  activityPercent?: number;
  depth: number;
}

function extractSqlId(lines: string[]): string | undefined {
  for (const line of lines) {
    const match = line.match(/SQL\s*ID[:\s]+(\w+)/i);
    if (match) {
      return match[1];
    }
  }
  return undefined;
}

function extractPlanHashValue(lines: string[]): string | undefined {
  for (const line of lines) {
    const match = line.match(/Plan Hash[^=\d]*[=:\s]+(\d+)/i);
    if (match) {
      return match[1];
    }
  }
  return undefined;
}

interface SqlMonitorColumnPositions {
  id: { start: number; end: number };
  operation: { start: number; end: number };
  name: { start: number; end: number };
  rows?: { start: number; end: number };
  cost?: { start: number; end: number };
  aRows?: { start: number; end: number };
  aTime?: { start: number; end: number };
  starts?: { start: number; end: number };
  memory?: { start: number; end: number };
  temp?: { start: number; end: number };
  reads?: { start: number; end: number };
  activity?: { start: number; end: number };
}

function parseSqlMonitorTable(lines: string[]): RawSqlMonitorRow[] {
  const rows: RawSqlMonitorRow[] = [];

  // Find the header line
  let headerLineIndex = -1;
  let headerLine = '';

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (/\|\s*Id\s*\|.*Operation/i.test(line)) {
      headerLineIndex = i;
      headerLine = line;
      break;
    }
  }

  if (headerLineIndex === -1) {
    return rows;
  }

  // Parse column positions
  const columns = parseSqlMonitorColumnPositions(headerLine);

  // Parse data rows
  for (let i = headerLineIndex + 1; i < lines.length; i++) {
    const line = lines[i];

    if (/^[-|=]+$/.test(line.trim()) || line.trim() === '') {
      if (/^[-|=]+$/.test(line.trim())) {
        let foundMoreData = false;
        for (let j = i + 1; j < lines.length; j++) {
          if (/^\|.*\d+.*\|/.test(lines[j])) {
            foundMoreData = true;
            break;
          }
          if (/^[-|=]+$/.test(lines[j].trim())) {
            break;
          }
        }
        if (!foundMoreData) {
          break;
        }
      }
      continue;
    }

    if (/^\|/.test(line)) {
      const row = parseSqlMonitorDataRow(line, columns);
      if (row) {
        rows.push(row);
      }
    }
  }

  return rows;
}

function parseSqlMonitorColumnPositions(headerLine: string): SqlMonitorColumnPositions {
  const cols: SqlMonitorColumnPositions = {
    id: { start: 0, end: 0 },
    operation: { start: 0, end: 0 },
    name: { start: 0, end: 0 },
  };

  const pipePositions: number[] = [];
  for (let i = 0; i < headerLine.length; i++) {
    if (headerLine[i] === '|') {
      pipePositions.push(i);
    }
  }

  const headerLower = headerLine.toLowerCase();
  let rowsSeen = false;

  for (let i = 0; i < pipePositions.length - 1; i++) {
    const start = pipePositions[i] + 1;
    const end = pipePositions[i + 1];
    const segment = headerLower.substring(start, end).trim();

    if (segment === 'id') {
      cols.id = { start, end };
    } else if (segment === 'operation') {
      cols.operation = { start, end };
    } else if (segment === 'name' || segment === 'object name') {
      cols.name = { start, end };
    } else if (segment === 'e-rows' || segment === 'rows' || segment === 'rows (estim)') {
      // Real SQL Monitor reports have two 'Rows' columns: first = estimated, second = actual
      if (segment === 'e-rows' || !rowsSeen) {
        cols.rows = { start, end };
        if (segment === 'rows') rowsSeen = true;
      } else {
        cols.aRows = { start, end };
      }
    } else if (segment.includes('cost')) {
      cols.cost = { start, end };
    } else if (segment === 'a-rows' || segment === 'actual rows' || segment === 'rows (actual)') {
      cols.aRows = { start, end };
    } else if (segment === 'a-time' || segment === 'actual time' || segment === 'time' || segment === 'time active(s)' || segment === 'time active (s)') {
      cols.aTime = { start, end };
    } else if (segment === 'starts' || segment === 'execs') {
      cols.starts = { start, end };
    } else if (segment.includes('mem') || segment === 'omem' || segment === 'used-mem') {
      cols.memory = { start, end };
    } else if (segment.includes('temp') || segment === 'used-tmp') {
      cols.temp = { start, end };
    } else if (segment === 'reads' || segment === 'physical reads') {
      cols.reads = { start, end };
    } else if (segment === 'activity' || segment === 'activity %') {
      cols.activity = { start, end };
    }
  }

  return cols;
}

function parseSqlMonitorDataRow(line: string, columns: SqlMonitorColumnPositions): RawSqlMonitorRow | null {
  const idStr = line.substring(columns.id.start, columns.id.end).trim();
  const idMatch = idStr.match(/\*?\s*(\d+)/);
  if (!idMatch) {
    return null;
  }

  const id = parseInt(idMatch[1], 10);

  const operationRaw = line.substring(columns.operation.start, columns.operation.end);
  const depth = calculateDepth(operationRaw);
  const operation = operationRaw.trim();

  if (!operation) {
    return null;
  }

  const objectName = line.substring(columns.name.start, columns.name.end).trim() || undefined;

  const row: RawSqlMonitorRow = {
    id,
    operation,
    objectName,
    depth,
  };

  if (columns.rows) {
    const val = parseNumericValue(line.substring(columns.rows.start, columns.rows.end).trim());
    if (val !== null) row.rows = val;
  }

  if (columns.cost) {
    const val = parseNumericValue(line.substring(columns.cost.start, columns.cost.end).trim());
    if (val !== null) row.cost = val;
  }

  if (columns.aRows) {
    const val = parseNumericValue(line.substring(columns.aRows.start, columns.aRows.end).trim());
    if (val !== null) row.actualRows = val;
  }

  if (columns.aTime) {
    const timeStr = line.substring(columns.aTime.start, columns.aTime.end).trim();
    const timeMs = parseTimeToMs(timeStr);
    if (timeMs !== null) row.actualTime = timeMs;
  }

  if (columns.starts) {
    const val = parseNumericValue(line.substring(columns.starts.start, columns.starts.end).trim());
    if (val !== null) row.starts = val;
  }

  if (columns.memory) {
    const val = parseMemoryValue(line.substring(columns.memory.start, columns.memory.end).trim());
    if (val !== null) row.memoryUsed = val;
  }

  if (columns.temp) {
    const val = parseMemoryValue(line.substring(columns.temp.start, columns.temp.end).trim());
    if (val !== null) row.tempUsed = val;
  }

  if (columns.reads) {
    const val = parseNumericValue(line.substring(columns.reads.start, columns.reads.end).trim());
    if (val !== null) row.physicalReads = val;
  }

  if (columns.activity) {
    const actStr = line.substring(columns.activity.start, columns.activity.end).trim();
    const actMatch = actStr.match(/([\d.]+)/);
    if (actMatch) row.activityPercent = parseFloat(actMatch[1]);
  }

  return row;
}

function calculateDepth(operationStr: string): number {
  let spaces = 0;
  for (const char of operationStr) {
    if (char === ' ') {
      spaces++;
    } else {
      break;
    }
  }
  return Math.floor(spaces / 1);
}

function parseNumericValue(str: string): number | null {
  const cleaned = str.replace(/,/g, '').trim();
  if (!cleaned || cleaned === '') return null;

  const suffixMatch = cleaned.match(/^([\d.]+)\s*([KMG])?$/i);
  if (suffixMatch) {
    let value = parseFloat(suffixMatch[1]);
    const suffix = (suffixMatch[2] || '').toUpperCase();
    if (suffix === 'K') value *= 1000;
    else if (suffix === 'M') value *= 1000000;
    else if (suffix === 'G') value *= 1000000000;
    return Math.round(value);
  }

  const num = parseInt(cleaned, 10);
  return isNaN(num) ? null : num;
}

function parseTimeToMs(timeStr: string): number | null {
  if (!timeStr) return null;

  // Format: HH:MM:SS.ss or SS.ss or similar
  const hhmmssMatch = timeStr.match(/(\d+):(\d+):(\d+)(?:\.(\d+))?/);
  if (hhmmssMatch) {
    const hours = parseInt(hhmmssMatch[1], 10);
    const minutes = parseInt(hhmmssMatch[2], 10);
    const seconds = parseInt(hhmmssMatch[3], 10);
    const fraction = hhmmssMatch[4] ? parseInt(hhmmssMatch[4], 10) / Math.pow(10, hhmmssMatch[4].length) : 0;
    return (hours * 3600 + minutes * 60 + seconds + fraction) * 1000;
  }

  // Just seconds
  const secMatch = timeStr.match(/([\d.]+)\s*(?:s|sec)?/i);
  if (secMatch) {
    return parseFloat(secMatch[1]) * 1000;
  }

  return null;
}

function parseMemoryValue(str: string): number | null {
  const cleaned = str.replace(/,/g, '').trim();
  if (!cleaned) return null;

  const match = cleaned.match(/^([\d.]+)\s*([KMGT])?B?$/i);
  if (match) {
    let value = parseFloat(match[1]);
    const suffix = (match[2] || '').toUpperCase();
    if (suffix === 'K') value *= 1024;
    else if (suffix === 'M') value *= 1024 * 1024;
    else if (suffix === 'G') value *= 1024 * 1024 * 1024;
    else if (suffix === 'T') value *= 1024 * 1024 * 1024 * 1024;
    return Math.round(value);
  }

  return parseNumericValue(str);
}

function parsePredicates(lines: string[]): Map<number, { access?: string; filter?: string }> {
  const predicates = new Map<number, { access?: string; filter?: string }>();

  // Find predicate section
  let inPredicateSection = false;
  let currentId: number | null = null;
  let currentType: 'access' | 'filter' | null = null;
  let currentText = '';

  for (const line of lines) {
    if (/Predicate Information/i.test(line)) {
      inPredicateSection = true;
      continue;
    }

    if (!inPredicateSection) {
      continue;
    }

    // Stop at next section or empty lines after predicates
    if (/^[A-Z].*:$/i.test(line.trim()) && !/^\s*\d+\s*-/.test(line)) {
      break;
    }

    // Parse predicate lines like "3 - access(...)" or "3 - filter(...)"
    const predicateMatch = line.match(/^\s*(\d+)\s*-\s*(access|filter)\s*\((.+)\)?\s*$/i);
    if (predicateMatch) {
      // Save previous predicate if any
      if (currentId !== null && currentType && currentText) {
        const existing = predicates.get(currentId) || {};
        existing[currentType] = currentText;
        predicates.set(currentId, existing);
      }

      currentId = parseInt(predicateMatch[1], 10);
      currentType = predicateMatch[2].toLowerCase() as 'access' | 'filter';
      currentText = predicateMatch[3] || '';

      // Handle case where predicate text is complete on this line
      if (currentText.endsWith(')') || !line.includes('(')) {
        const existing = predicates.get(currentId) || {};
        existing[currentType] = currentText.replace(/\)$/, '');
        predicates.set(currentId, existing);
        currentId = null;
        currentType = null;
        currentText = '';
      }
    } else if (currentId !== null && currentType && line.trim()) {
      // Continuation of multi-line predicate
      currentText += ' ' + line.trim();
      if (line.trim().endsWith(')')) {
        const existing = predicates.get(currentId) || {};
        existing[currentType] = currentText.replace(/\)$/, '');
        predicates.set(currentId, existing);
        currentId = null;
        currentType = null;
        currentText = '';
      }
    }
  }

  // Save any remaining predicate
  if (currentId !== null && currentType && currentText) {
    const existing = predicates.get(currentId) || {};
    existing[currentType] = currentText.replace(/\)$/, '');
    predicates.set(currentId, existing);
  }

  return predicates;
}

function buildTree(
  rows: RawSqlMonitorRow[],
  predicates: Map<number, { access?: string; filter?: string }>
): { rootNode: PlanNode | null; allNodes: PlanNode[] } {
  if (rows.length === 0) {
    return { rootNode: null, allNodes: [] };
  }

  const nodeMap = new Map<number, PlanNode>();
  const allNodes: PlanNode[] = [];

  for (const row of rows) {
    const preds = predicates.get(row.id);
    const node: PlanNode = {
      id: row.id,
      depth: row.depth,
      operation: row.operation,
      objectName: row.objectName,
      rows: row.rows,
      cost: row.cost,
      actualRows: row.actualRows,
      actualTime: row.actualTime,
      starts: row.starts,
      memoryUsed: row.memoryUsed,
      tempUsed: row.tempUsed,
      physicalReads: row.physicalReads,
      activityPercent: row.activityPercent,
      accessPredicates: preds?.access,
      filterPredicates: preds?.filter,
      children: [],
    };

    nodeMap.set(row.id, node);
    allNodes.push(node);
  }

  // Build parent-child relationships
  for (let i = 1; i < rows.length; i++) {
    const currentRow = rows[i];
    const currentNode = nodeMap.get(currentRow.id)!;

    for (let j = i - 1; j >= 0; j--) {
      const potentialParentRow = rows[j];
      if (potentialParentRow.depth < currentRow.depth) {
        const parentNode = nodeMap.get(potentialParentRow.id)!;
        parentNode.children.push(currentNode);
        currentNode.parentId = parentNode.id;
        break;
      }
    }
  }

  const rootNode = nodeMap.get(0) || allNodes[0] || null;
  return { rootNode, allNodes };
}

// ============================================================
// Real Oracle SQL Monitor XML parser
// Handles DBMS_SQL_MONITOR.REPORT_SQL_MONITOR(type=>'XML') output
// ============================================================

/** Data extracted from the <plan> section (optimizer estimates + predicates) */
interface PlanEstimates {
  rows?: number;
  bytes?: number;
  cost?: number;
  objectName?: string;
  objectAlias?: string;
  queryBlock?: string;
  accessPredicates?: string;
  filterPredicates?: string;
  options?: string;
}

function parseRealOracleXml(doc: Document): ParsedPlan {
  // Extract metadata from <report_parameters> and <target>
  const reportParams = doc.querySelector('report_parameters');
  const target = doc.querySelector('target');

  const sqlId =
    reportParams?.querySelector('sql_id')?.textContent?.trim() ||
    target?.getAttribute('sql_id') ||
    undefined;

  const planHashValue =
    target?.getAttribute('sql_plan_hash') ||
    reportParams?.querySelector('plan_hash')?.textContent?.trim() ||
    undefined;

  // SQL text from <target><sql_fulltext>
  const sqlText = target?.querySelector('sql_fulltext')?.textContent?.trim() || undefined;

  // Global elapsed time from <stats type="monitor">
  const globalStats = doc.querySelector('stats[type="monitor"]');
  const globalElapsedTimeUs = getStatByName(globalStats, 'elapsed_time');

  // Parse the <plan> section for estimated stats and predicates
  const planEstimatesMap = parsePlanSection(doc);

  // Parse the <plan_monitor> section for actual runtime stats
  const allNodes: PlanNode[] = [];
  const nodeMap = new Map<number, PlanNode>();

  const planMonitor = doc.querySelector('plan_monitor');
  if (planMonitor) {
    // Parse operations from <plan_monitor>
    const operations = planMonitor.querySelectorAll(':scope > operation');
    operations.forEach((op) => {
      const node = parseMonitorOperation(op, planEstimatesMap);
      if (node) {
        nodeMap.set(node.id, node);
        allNodes.push(node);
      }
    });
  } else {
    // Fallback: try operations under <plan> if no <plan_monitor> exists
    const planSection = doc.querySelector('plan');
    if (planSection) {
      const operations = planSection.querySelectorAll(':scope > operation');
      operations.forEach((op) => {
        const node = parsePlanOnlyOperation(op);
        if (node) {
          nodeMap.set(node.id, node);
          allNodes.push(node);
        }
      });
    }
  }

  // Build parent-child relationships
  // <plan_monitor> operations have parent_id, <plan> operations use depth
  const hasParentIds = allNodes.some(n => n.parentId !== undefined);
  if (hasParentIds) {
    allNodes.forEach((node) => {
      if (node.parentId !== undefined) {
        const parent = nodeMap.get(node.parentId);
        if (parent) {
          parent.children.push(node);
        }
      }
    });
  } else {
    // Build tree from depth (for <plan>-only format)
    for (let i = 1; i < allNodes.length; i++) {
      const current = allNodes[i];
      for (let j = i - 1; j >= 0; j--) {
        if (allNodes[j].depth < current.depth) {
          allNodes[j].children.push(current);
          current.parentId = allNodes[j].id;
          break;
        }
      }
    }
  }

  // Find root node (id 0, or node without parent_id)
  const rootNode = nodeMap.get(0) || allNodes.find(n => n.parentId === undefined) || null;

  // Calculate totals
  const totalCost = allNodes.reduce((sum, node) => sum + (node.cost || 0), 0);
  const maxRows = Math.max(...allNodes.map(node => node.actualRows || node.rows || 0), 0);
  const maxActualRows = Math.max(...allNodes.map(node => node.actualRows || 0), 0);
  const maxStarts = Math.max(...allNodes.map(node => node.starts || 0), 0);
  const hasActualStats = allNodes.some(node => node.actualRows !== undefined);
  // Global elapsed time in milliseconds (Oracle stores in microseconds)
  const totalElapsedTime = globalElapsedTimeUs
    ? globalElapsedTimeUs / 1000
    : (rootNode?.actualTime || 0);

  return {
    planHashValue,
    sqlId,
    sqlText,
    rootNode,
    allNodes,
    totalCost,
    maxRows,
    maxActualRows: hasActualStats ? maxActualRows : undefined,
    maxStarts: hasActualStats ? maxStarts : undefined,
    source: 'sql_monitor_xml',
    hasActualStats,
    totalElapsedTime,
  };
}

/**
 * Parse the <plan> section to extract optimizer estimates and predicates.
 * Returns a map from operation id to estimated data.
 */
function parsePlanSection(doc: Document): Map<number, PlanEstimates> {
  const result = new Map<number, PlanEstimates>();
  const planSection = doc.querySelector('plan');
  if (!planSection) return result;

  const operations = planSection.querySelectorAll(':scope > operation');
  operations.forEach((op) => {
    const idAttr = op.getAttribute('id');
    if (!idAttr) return;
    const id = parseInt(idAttr, 10);
    if (isNaN(id)) return;

    const estimates: PlanEstimates = {};

    // Estimated cardinality (rows)
    const card = op.querySelector(':scope > card');
    if (card?.textContent) {
      estimates.rows = parseInt(card.textContent, 10) || undefined;
    }

    // Bytes
    const bytes = op.querySelector(':scope > bytes');
    if (bytes?.textContent) {
      estimates.bytes = parseInt(bytes.textContent, 10) || undefined;
    }

    // Cost
    const cost = op.querySelector(':scope > cost');
    if (cost?.textContent) {
      estimates.cost = parseInt(cost.textContent, 10) || undefined;
    }

    // Object name (simple text in <plan> section)
    const obj = op.querySelector(':scope > object');
    if (obj?.textContent && !obj.querySelector('name')) {
      estimates.objectName = obj.textContent.trim();
    }

    // Object alias
    const alias = op.querySelector(':scope > object_alias');
    if (alias?.textContent) {
      estimates.objectAlias = alias.textContent.trim();
    }

    // Query block
    const qblock = op.querySelector(':scope > qblock');
    if (qblock?.textContent) {
      estimates.queryBlock = qblock.textContent.trim();
    }

    // Predicates: <predicates type="access|filter">
    const predicateElements = op.querySelectorAll(':scope > predicates');
    predicateElements.forEach((pred) => {
      const type = pred.getAttribute('type');
      const text = pred.textContent?.trim();
      if (text) {
        if (type === 'access') {
          estimates.accessPredicates = text;
        } else if (type === 'filter') {
          estimates.filterPredicates = text;
        }
      }
    });

    // Options attribute
    const options = op.getAttribute('options');
    if (options) {
      estimates.options = options;
    }

    result.set(id, estimates);
  });

  return result;
}

/**
 * Parse an operation element from the <plan_monitor> section.
 * Merges with estimated data from <plan> section.
 */
function parseMonitorOperation(op: Element, planEstimates: Map<number, PlanEstimates>): PlanNode | null {
  const idAttr = op.getAttribute('id');
  if (!idAttr) return null;
  const id = parseInt(idAttr, 10);
  if (isNaN(id)) return null;

  // Build operation name from name + options attributes
  const name = op.getAttribute('name') || '';
  const options = op.getAttribute('options') || '';
  const operation = options ? `${name} ${options}` : name;
  const depth = parseInt(op.getAttribute('depth') || '0', 10);

  // Object name: <object type="TABLE"><owner>X</owner><name>Y</name></object>
  const objectEl = op.querySelector(':scope > object');
  let objectName: string | undefined;
  if (objectEl) {
    const nameEl = objectEl.querySelector('name');
    objectName = nameEl?.textContent?.trim() || objectEl.textContent?.trim() || undefined;
  }

  // Optimizer estimates from <optimizer> sub-element in <plan_monitor>
  const optimizer = op.querySelector(':scope > optimizer');
  let rows: number | undefined;
  let bytes: number | undefined;
  let cost: number | undefined;

  if (optimizer) {
    const card = optimizer.querySelector('cardinality');
    if (card?.textContent) rows = parseInt(card.textContent, 10) || undefined;
    const bytesEl = optimizer.querySelector('bytes');
    if (bytesEl?.textContent) bytes = parseInt(bytesEl.textContent, 10) || undefined;
    const costEl = optimizer.querySelector('cost');
    if (costEl?.textContent) cost = parseInt(costEl.textContent, 10) || undefined;
  }

  // Merge with <plan> section estimates (predicates, aliases, etc.)
  const estimates = planEstimates.get(id);
  if (estimates) {
    if (rows === undefined) rows = estimates.rows;
    if (bytes === undefined) bytes = estimates.bytes;
    if (cost === undefined) cost = estimates.cost;
    if (!objectName) objectName = estimates.objectName;
  }

  // Parse actual runtime stats from <stats type="plan_monitor">
  const statsEl = op.querySelector('stats[type="plan_monitor"]');
  const actualRows = getStatByName(statsEl, 'cardinality');
  const starts = getStatByName(statsEl, 'starts');
  const maxMemory = getStatByName(statsEl, 'max_memory');
  const maxTempSeg = getStatByName(statsEl, 'max_tempseg');
  const readReqs = getStatByName(statsEl, 'read_reqs');
  const readBytes = getStatByName(statsEl, 'read_bytes');
  const elapsedTimeUs = getStatByName(statsEl, 'elapsed_time');
  const duration = getStatByName(statsEl, 'duration');

  // Elapsed time: prefer elapsed_time (microseconds), fallback to duration (seconds)
  let actualTimeMs: number | undefined;
  if (elapsedTimeUs !== undefined) {
    actualTimeMs = elapsedTimeUs / 1000;
  } else if (duration !== undefined) {
    actualTimeMs = duration * 1000;
  }

  const node: PlanNode = {
    id,
    depth,
    operation,
    objectName,
    objectAlias: estimates?.objectAlias,
    queryBlock: estimates?.queryBlock,
    rows,
    bytes,
    cost,
    actualRows,
    actualTime: actualTimeMs,
    starts,
    memoryUsed: maxMemory,
    tempUsed: maxTempSeg,
    physicalReads: readReqs || readBytes,
    logicalReads: undefined, // buffer_gets is at global level, not per-operation
    accessPredicates: estimates?.accessPredicates,
    filterPredicates: estimates?.filterPredicates,
    children: [],
  };

  // Parent ID
  const parentAttr = op.getAttribute('parent_id');
  if (parentAttr) {
    node.parentId = parseInt(parentAttr, 10);
  }

  return node;
}

/**
 * Parse an operation from <plan> section only (when no <plan_monitor> exists).
 * Uses the <plan> format where estimates are direct child elements.
 */
function parsePlanOnlyOperation(op: Element): PlanNode | null {
  const idAttr = op.getAttribute('id');
  if (!idAttr) return null;
  const id = parseInt(idAttr, 10);
  if (isNaN(id)) return null;

  const name = op.getAttribute('name') || '';
  const options = op.getAttribute('options') || '';
  const operation = options ? `${name} ${options}` : name;
  const depth = parseInt(op.getAttribute('depth') || '0', 10);

  // Simple object name
  const objectEl = op.querySelector(':scope > object');
  const objectName = objectEl?.textContent?.trim() || undefined;

  const node: PlanNode = {
    id,
    depth,
    operation,
    objectName,
    objectAlias: op.querySelector(':scope > object_alias')?.textContent?.trim(),
    queryBlock: op.querySelector(':scope > qblock')?.textContent?.trim(),
    rows: getDirectChildInt(op, 'card'),
    bytes: getDirectChildInt(op, 'bytes'),
    cost: getDirectChildInt(op, 'cost'),
    children: [],
  };

  // Predicates
  const predicateElements = op.querySelectorAll(':scope > predicates');
  predicateElements.forEach((pred) => {
    const type = pred.getAttribute('type');
    const text = pred.textContent?.trim();
    if (text) {
      if (type === 'access') node.accessPredicates = text;
      else if (type === 'filter') node.filterPredicates = text;
    }
  });

  // Build parent-child by depth (no parent_id in <plan> operations)
  // Parent relationships will be built by the tree builder based on depth+position

  return node;
}

/**
 * Get a named stat value from a <stats> element.
 * Stats are structured as <stat name="...">value</stat>.
 */
function getStatByName(statsEl: Element | null, name: string): number | undefined {
  if (!statsEl) return undefined;
  const stats = statsEl.querySelectorAll('stat');
  for (const stat of stats) {
    if (stat.getAttribute('name') === name) {
      const val = stat.textContent?.trim();
      if (val) {
        const num = parseFloat(val);
        return isNaN(num) ? undefined : num;
      }
    }
  }
  return undefined;
}

/** Get an integer value from a direct child element. */
function getDirectChildInt(parent: Element, tagName: string): number | undefined {
  const el = parent.querySelector(`:scope > ${tagName}`);
  if (!el?.textContent) return undefined;
  const num = parseInt(el.textContent.trim(), 10);
  return isNaN(num) ? undefined : num;
}

// ============================================================
// Legacy XML parser (for backward compatibility with simplified format)
// ============================================================

function parseLegacyXml(doc: Document): ParsedPlan {
  // Extract metadata
  const sqlId = getXmlText(doc, 'sql_id');
  const planHashValue = getXmlText(doc, 'plan_hash');
  const sqlText = getXmlText(doc, 'sql_text');

  // Parse plan operations (legacy: flat <operation> elements or under <plan_operations>)
  const operations = doc.querySelectorAll('operation');
  const allNodes: PlanNode[] = [];
  const nodeMap = new Map<number, PlanNode>();

  operations.forEach((op) => {
    const node = parseLegacyXmlOperation(op);
    if (node) {
      nodeMap.set(node.id, node);
      allNodes.push(node);
    }
  });

  // Build parent-child relationships
  allNodes.forEach((node) => {
    if (node.parentId !== undefined) {
      const parent = nodeMap.get(node.parentId);
      if (parent) {
        parent.children.push(node);
      }
    }
  });

  const rootNode = nodeMap.get(0) || allNodes.find(n => n.parentId === undefined) || null;

  const totalCost = allNodes.reduce((sum, node) => sum + (node.cost || 0), 0);
  const maxRows = Math.max(...allNodes.map(node => node.actualRows || node.rows || 0), 0);
  const maxActualRows = Math.max(...allNodes.map(node => node.actualRows || 0), 0);
  const maxStarts = Math.max(...allNodes.map(node => node.starts || 0), 0);
  const hasActualStats = allNodes.some(node => node.actualRows !== undefined);
  const totalElapsedTime = rootNode?.actualTime || 0;

  return {
    planHashValue,
    sqlId,
    sqlText,
    rootNode,
    allNodes,
    totalCost,
    maxRows,
    maxActualRows: hasActualStats ? maxActualRows : undefined,
    maxStarts: hasActualStats ? maxStarts : undefined,
    source: 'sql_monitor_xml',
    hasActualStats,
    totalElapsedTime,
  };
}

function getXmlText(doc: Document, tagName: string): string | undefined {
  const element = doc.querySelector(tagName);
  return element?.textContent?.trim() || undefined;
}

function parseLegacyXmlOperation(op: Element): PlanNode | null {
  const idAttr = op.getAttribute('id');
  if (!idAttr) return null;

  const id = parseInt(idAttr, 10);
  const operation = op.getAttribute('name') || op.querySelector('operation_name')?.textContent || '';
  const depth = parseInt(op.getAttribute('depth') || '0', 10);

  const node: PlanNode = {
    id,
    depth,
    operation,
    objectName: op.getAttribute('object_name') || op.querySelector('object_name')?.textContent || undefined,
    rows: parseLegacyXmlNumber(op, 'cardinality') || parseLegacyXmlNumber(op, 'e_rows'),
    bytes: parseLegacyXmlNumber(op, 'bytes'),
    cost: parseLegacyXmlNumber(op, 'cost'),
    actualRows: parseLegacyXmlNumber(op, 'output_rows') || parseLegacyXmlNumber(op, 'a_rows'),
    actualTime: parseLegacyXmlNumber(op, 'elapsed_time'),
    starts: parseLegacyXmlNumber(op, 'starts'),
    memoryUsed: parseLegacyXmlNumber(op, 'max_memory') || parseLegacyXmlNumber(op, 'used_mem'),
    tempUsed: parseLegacyXmlNumber(op, 'temp_space') || parseLegacyXmlNumber(op, 'used_tmp'),
    physicalReads: parseLegacyXmlNumber(op, 'physical_reads') || parseLegacyXmlNumber(op, 'cr_buffer_gets'),
    logicalReads: parseLegacyXmlNumber(op, 'logical_reads') || parseLegacyXmlNumber(op, 'buffer_gets'),
    activityPercent: parseLegacyXmlFloat(op, 'activity_percent') || parseLegacyXmlFloat(op, 'percent'),
    accessPredicates: op.querySelector('access_predicates')?.textContent?.trim() ||
      op.getAttribute('access_predicates') || undefined,
    filterPredicates: op.querySelector('filter_predicates')?.textContent?.trim() ||
      op.getAttribute('filter_predicates') || undefined,
    children: [],
  };

  const parentAttr = op.getAttribute('parent_id');
  if (parentAttr) {
    node.parentId = parseInt(parentAttr, 10);
  }

  return node;
}

function parseLegacyXmlNumber(element: Element, tagName: string): number | undefined {
  const value = element.getAttribute(tagName) || element.querySelector(tagName)?.textContent;
  if (!value) return undefined;
  const num = parseInt(value, 10);
  return isNaN(num) ? undefined : num;
}

function parseLegacyXmlFloat(element: Element, tagName: string): number | undefined {
  const value = element.getAttribute(tagName) || element.querySelector(tagName)?.textContent;
  if (!value) return undefined;
  const num = parseFloat(value);
  return isNaN(num) ? undefined : num;
}
